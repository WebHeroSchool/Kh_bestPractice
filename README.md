# Практика хорошего кода

## 1. Разница между  *let*, *var*, *const*

> var – старая версия объявления
>> let, const – новая спецификация

*let* и *var* имеют несколько отличий.

| let | var |
| ------ | ----------- |
| let Видна только в рамках блока, в котором объявлена 
| var Видна везде в функции |
| let До объявления их не существует 
| var Существуют и до объявления и равны `undefined`|
| let Нельзя повторно объявлять 
| var Можно повторно объявлять |
| let При использовании в цикле, для каждой итерации создаётся своя переменная 
| var Одна на все итерации цикла и видна даже после цикла |

```js
for (var i = 1; i < 10; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
```



## 2. Названия переменных.

Необходимо давать переменным осмысленные имена, это улучшает читабельность и дает представление о том, для чего нужна в коде эта переменная.

Хорошей практикой было бы использвать, например:

* `isActive  = true` - для булевых значений
* `getUser = function(){}` - для функций
* `const MY_CONSTANT` - для констант
* `let myName` - для обычной переменной

---


## 3. Использование стрелочных функций.

В ES6 появилась возможность использовать стрелочные функции. Однако стоит разобраться, чтобы лучше понимать, когда их необходимо использовать.

Стрелочные функции имеют упрощённый синтаксис

`func = () => console.log('Привет');`

Всё равно что:

```js
const func = function() {
    return console.log('Hello');
}
```

* *Отсутсвие привязки контекста*

В выражениях функций *this* привязан к различным значениям, основанным на контексте, в котором он вызывается. Однако со стрелочными функциями *this* лексически связан. Это означает, что *this* используется из кода, содержащего функцию стрелки.

```js
var obj = {
    number: 10,
    counter: function counter() {
        setTimeout(() => {
            console.log(this.number)
        }, 1000)
    }
};
```

Стрелочные функции ES6 не могут быть привязаны к ключевому слову *this*, поэтому он будет использовать значение *this* в области, в которой он был определен.


* *Не стоит использовать стрелочные функции в рекурсивном решении*

Если функция должна ссылаться на саму себя.

* *Не стоит использовать стрелочные функции в методах объекта*

```js
var user = {
    name: 'John',
    sayHi: () => {
        console.log(`Hi, ${this.name}`);
    }
}

user.sayHi();
```

Это связано с тем, что this не связано ни с чем, и наследует значение this из его родительской области.

Стрелочные функции лучше всего подходят когда требуется от this привязка к контексту, а не к самой функции.

---

## 4. Преимущество работы с class.

ООП в JS представлено условно специальными функциями-конструкторами и классами.

При создании нового экземпляра объекта, отнаследованного от Component, метод this.render будет создаваться каждый раз заново.

```js
function Component(content) {
    this.content = content;
    this.first = "first";
    this.second = "second";
    this.render = () => {
        console.log(this.content);
    }
}
```

Поэтому кастомным объектам можно добавить функцию в свойство prototype, которая будет создана один раз и записана в `__proto__`. Таким образом, каждый раз, когда будет вызываться метод `render`, JS будет брать его из прототипа (`__proto__`).

```js
function Component(content) {
    this.content = content;
    this.first = "first";
    this.second = "second";
}
Component.prototype.render = function() {
    console.log(this.content);
}
```

При появлении в JS классов, эта строчка с присвоением Component.prototype.render = ... - оказалась не нужна, потому что это уже реализовано в самом class.

```js
class Component {
    constructor(content) {
        this.content = content;
        this.first = "first";
        this.second = "second";
    }

    render() {
        console.log(this.content);
    }
}
```

Также, при использовании классов при итерации по свойствам объекта, эти методы указаны не будут, потому что им сразу ставится флаг `enumerable`, в отличие от использования функций-конструкторов.

```js
class Component {
    constructor(content) {
        this.content = content;
        this.first = "first";
        this.second = "second";
    }

    render() {
        console.log(this.content);
    }
};

let instance = new Component("content");

for (i in instance) {
    console.log(i); //content, first, second
};
```

---

## 5. Использование тернарных операторов.

В качестве укороченного варианта условного оператора `if` используют ***тернарный оператор***.
`условие ? выражение1 : выражение2`

Данный оператор возвращает значение выражения1, если условие верно, *и* значение выражения2 в противном случае.

```js
var price = 100;
var buy = fruit > 99 ? 'Apple' : 'Banana';
console.log(buy);
```
---

## 6. KISS / DRY.

Принцип проектирования ***KISS*** (keep it simple and straightforward) говорит о том что, простой код – наиболее понятный.
Принципы KISS:*

+ не имеет смысла реализовывать дополнительные функции, которые не будут использоваться вовсе или их использование крайне маловероятно, как правило, большинству пользователей достаточно базового функционала, а усложнение только вредит удобству приложения;

+ не стоит перегружать интерфейс теми опциями, которые не будут нужны большинству пользователей, гораздо проще предусмотреть для них отдельный «расширенный» интерфейс (или вовсе отказаться от данного функционала);

+ бессмысленно делать реализацию сложной бизнес-логики, которая учитывает абсолютно все возможные варианты поведения системы, пользователя и окружающей среды, — во-первых, это просто невозможно, а во-вторых, такая фанатичность заставляет собирать «звездолёт», что чаще всего иррационально с коммерческой точки зрения.

*В программировании следование принципу KISS можно описать так:*

+ не имеет смысла беспредельно увеличивать уровень абстракции;

+ не нужно закладывать в проект избыточные функции;

+ не стоит подключать огромную библиотеку, если  нужна лишь пара функций;

+ декомпозиция  сложного на простые составляющие;

+  математическая точность или предельная детализация нужны не всегда —  данные  нужно обрабатывать с той точностью, которая достаточна для качественного решения задачи, а детализацию выдавать в нужном пользователю объёме, а не в максимально возможном объёме.

Следование принципу программирования ***«DRY»*** позволяет добиться высокой сопровождаемости проекта: простоты внесения изменений и качественного тестирования.

 Следование принципу *DRY* всегда приводит к декомпозиции сложных алгоритмов на простые функции. А декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает понимание программного кода. Повторное использование функций, вынесенных из сложных алгоритмов, позволяет сократить время разработки и тестирования новой функциональности.

Так же доступ к конкретному функционалу должен быть доступен в одном месте, унифицирован и сгруппирован по какому-либо принципу, а не «разбросан» по системе в произвольных вариациях.

---

## 7. Использование === вместо ==.

В JavaScript существует два разных типа операций сравния: === / !== и == / !=. Считается хорошим тоном всегда использовать первую пару для сравнения.

Если два операнда одного типа и значения, то === вернет true, а !== false.

```js
""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
```

## 8.  Используйте короткую запись.

Если в условии содержится одно выражение, то его можно записать без фигурных скобок

```js
if (isDarkTheme) showAlert();
```

---


## 9. Комментарии в коде.

Комментарии позволяют сделать код более понятным для восприятия и помогают лучше понять логику кода.

***Комментарии должны пояснять непонятные моменты***, трудные или спорные ситуации.

Не нужно комментировать очевидные вещи:

```js
/* функция возвращает результат суммы чисел */

getSum = (a, b, c) => a + b + c;
```

В комментарии следует указать, какое решение вы пытались найти и почему вы решили, что оно не подходит в данной ситуации или не работает.

```js
/* не используйте глобальную функцию isFinite(),
потому что она возвращает true для
нулевых значений */

Number.isFinite(value);
```
---

## 10. Использование встроенных функций языка.

В JS есть стандартные встроенные методы объектов. Они намного оптимизированнее, занимают меньше кода.

Например, использование методов *forEach*, *map*, *filter*, *reduce*, *every*, *some* лучше скажутся на производительности кода и его понимании.

---

&#x1F539;
WebHero
&#x1F538;
